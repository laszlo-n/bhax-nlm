<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Amennyire kivettem a feladatból és a videóból, itt igazából ismét az OO szerkezeten van hangsúly, nem konkrétan a működésen. A hangyák mind külön osztálypéldányok, és úgy hatnak egymásra. Maga a feladat valamennyire hasonlít az életjátékra (ld. 7.2), de nem ugyanazt a működést valósítja meg.

Az UML diagram (vagy legalábbis valami ahhoz nagyon hasonló) a könyvben linkelt forrásban is megtalálható. A legfontosabb megfigyelés talán itt, hogy minden Ant külön szálon, AntThread-en fut.
        </para>            
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://processing.org/examples/gameoflife.html">https://processing.org/examples/gameoflife.html</link>               
        </para>
        <para>
            Ez már sokkal közelebb áll hozzám. Conway életjátékának a szabályainak az ismertetésétől most eltekintenék, akit érdekel, itt elolvashatja: <link xlink:href="https://hu.wikipedia.org/wiki/Életjáték">https://hu.wikipedia.org/wiki/Életjáték</link>.

Maga a játéknak a célja filozófiai vonatkozású. Azt példázza, hogy néhány, egyszerű szabály segítségével nagyon komplex működések és folyamatok alakulhatnak ki. Erre egy példa a feladat utasításában megemlített "sikló-kilövő" is, amely mozgásban is látható a hivatkozott Wikipédia-oldalon.
        
        A kód működtetéséhez a Processing nevű eszközre lesz szükség.

A működése nem túl bonyolult, pláne nem valakinek aki már dolgozott Processinggel (aki még nem, annak ajánlom!). Először a setup() metódusban felvesszük a cellarácsot, és véletlenszerűen kitöltjük cellákkal. Ezt követően a draw() felelős minden újonnan megrajzolt képkockért, onnan kerül meghívásra az iteration() metódus, mely a játéklogika alkalmazásáért felelős.

A kód tartalmaz némi interaktív részt is, nevezetesen lehetővé teszi a szimuláció megállítását, és a cellák kézzel kitöltését is, egyedi formákat lehetővé téve.
        </para>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
