<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
	<info>
		<title>Helló, Mandelbrot!</title>
		<keywordset>
			<keyword/>
		</keywordset>
	</info>
	<section>
		<title>EPAM: Neptun tantárgyfelvétel modellezése UML-ben</title>
		<para>
			<informalfigure>
				<graphic fileref="images/fc2bf2ff.png"></graphic>
			</informalfigure>
			Itt azóta történt annyi változás, hogy a Subject-Lecturere kompozíció megszűnt.
		</para>
	</section>
	<section>
		<title>EPAM: Neptun tantárgyfelvétel UML diagram implementálása</title>
		<para>A kódot a bhax-sources mappába tettem targyfelv néven.</para>
	</section>
	<section>
		<title>EPAM: OO modellezés</title>
		<para>
			OO modellezés során többféle megközelítés lehetséges. A cél általában mindig a flexibilitás fenntartása, felesleges komplexitás és technical debt hozzáadásának elkerülésével. Erre kitaláltak már korábban pár elvet, vegyük is őket sorra!
		</para>
		<para>
			<emphasis>YAGNI:</emphasis> Rövidítése a "you aint gonna need it" kifejezésnek, azaz hogy "nem lesz rá szükséged". Célja az overengineering megfékezése azáltal, hogy elgondolkodtat arról, valóban szükségünk van-e egy adott absztrakcióra, vagy ráér-e még később. Természetéből adódóan ez szükségszerűvé teszi pl. a folytonos refaktorálás, a folytonos unit tesztelést és a folytonos integrációt. Nem megfelelően alkalmazva könnyedén okozhat kaotikus kódbázist, és nagy technical debtet.
		</para>
		<para>
			<emphasis>DRY:</emphasis> Rövidítése a "don't repeat yourself"-nek, azaz hogy "ne ismételd magad". Célja a kód duplikáció minimalizálása, és az ezek miatt kialakuló bugok elkerülése.
		</para>
		<para>
			<emphasis>SOLID:</emphasis> A SOLID egy mozaikszó, ami a következőket öleli magába: Single responsibility principle, Open/closed principle, Liskov substitution principle, Interface segregation principle, Dependency inversion principle. Ebből az LSP-t már tárgyaltam ebben a könyvben, úgyhogy nézzük a többit!
			<itemizedlist>
				<listitem>
					<para><emphasis>Single responsibility principle:</emphasis>Ahogy ezt a félév során sokszor tárgyaltuk, törekedni kell a metódusok, osztályok, komponensek, stb. felelőségének minimálisra limitálására, lehetőleg egyre. Ezzel modulárisabb, és könnyebben kezelhető lesz a kód, illetve csökken a dependenciák mélysége és számossága.</para>
				</listitem>
				<listitem>
					<para><emphasis>Open/closed principle:</emphasis>Az osztályokat, modulokat ki lehessen terjeszteni, de beléjük módosítani ne lehessen.</para>
				</listitem>
				<listitem>
					<para><emphasis>LSP:</emphasis>Lásd a korábbi fejezet, de amúgy az általánosabb osztályok specifikusabbal behelyetthetőségről szól.</para>
				</listitem>
				<listitem>
					<para><emphasis>Interfész-elválasztási elv:</emphasis>Törekedni kell arra, hogy egy adott interfész vagy modul consume-olásához ne kelljen olyan interfésszeket ill. modulokat behúznia a felhasználónak, amire nincs igazából szüksége.</para>
				</listitem>
				<listitem>
					<para><emphasis>Függőség-megfordítási elv:</emphasis>Mind a magas és alacsony szintű modulok absztrakcióktól kell függjenek, nem egymástól, és az absztrakciók ne függjenek implementációktól.</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			<emphasis>TellDontAsk:</emphasis> Ez a principle arra szólít fel, hogy ahelyett hogy arra kérnénk objektumokat hogy adatot adjanak nekünk vissza, inkább kérjük meg őket arra, hogy csináljanak velük valamit. Ez elősegíti az OO gondolkodást és az adat-logika couplingját, practically antitézist állítva az anemikus megközelítésnek.
		</para>
		<para>
			<emphasis>Anemic domain model:</emphasis> Ez a megközelítés minimalizálja a business logikát az objektumokban, itt beanekre, daokra kell gondolni.
		</para>
	</section>
</chapter>