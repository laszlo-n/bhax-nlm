<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
	<info>
		<title>Helló, Gödel!</title>
		<keywordset>
			<keyword/>
		</keywordset>
	</info>
	<section>
		<title>EPAM: XML feldolgozás</title>
		<para>
			Ld. a források közt az xml-to-svg mappát. Writeup soon™.
		</para>
	</section>
	<section>
		<title>EPAM: ASCII Art</title>
		<para>
			A feladat itt az volt, hogy olvassunk be egy tetszőleges formátumú képet, majd nyomtassuk ki a konzolra ascii artként. Ehhez ugye először át kell alakítsuk majd grayscale-é a bemeneti képet, mivel a karakterek csak egyféle értéket tudnak majd leképezni. Az egyszerűség kedvéért, én 1:1 mappinget használtam, azaz 1 pixel 1 karakter lesz, a karaktert magát pedig majd a pixel grayscale értéke határozza majd meg. Általában az ASCII artok fixed karakterekből állnak viszont, ami feltételez egy lossy mappinget. Úgyhogy a végleges transzformációt ezen (https://stackoverflow.com/questions/22649629/convert-contents-of-an-image-into-an-ascii-image) a linken hivatkozott kód (https://gist.github.com/shmert/3859200) alapján írtam meg.
		</para>
		<para>
			Ennek a feladatnak a megoldása a források közt az asciiart mappában található. Mellékeltem egy ok.png példa képet ugyanabban a mappában.
		</para>
	</section>
	<section>
		<title>EPAM: Titkos üzenet, száll a gépben!</title>
		<para>
			A feladat az volt, hogy írjunk egy Java programot, ami a bemenetről olvas sorokat, és Caesar-kódolva egy fájlba menti (soronként). Szerencsémre egy ehhez nagyon hasonló feladatot már kellett implementálnom Pythonban egy másik tárgyra, úgyhogy a logikát onnan fogom portolni. Maga az algoritmus amúgy rendkívül egyszerű. A Caesar-kódolás annyit jelent, hogy a bemeneti karaktereket az ábécében egy fixed mennyiséggel eltoljuk. Az "A"-ból így lesz pl. "B", ha az eltolás mértékét 1-nek választjuk. Az eltolási folyamat wrappel, azaz ha "túltoljuk", az ábécé elejéről kezdünk el elemeket bevenni.
		</para>
		<para>
			A korábban megírt Python programom:
			<programlisting language="python"><![CDATA[
#!/usr/bin/env python3
# coding: utf-8

rejtelyes_szoveg = """
Cbcq Dgyk!

Dmeybh kce cew yrwyg hmrylyaqmr:
rylsjb kce y Nwrfml npmepykmxyqg lwcjtcr!

Aqmimjjyi:

Ynyb
""".strip()

def decode_message(text):
    txt = []
    for character in text:
        if ord(character) in range(65, 65 + 26):
            txt.append(chr((ord(character) - 63) % 26 + 65))
        elif ord(character) in range(97, 97 + 26):
            txt.append(chr((ord(character) - 95) % 26 + 97))
        else:
            txt.append(character)
    return ''.join(txt)

def main():
    print("Eredeti szöveg:")
    print("-" * 15 + "\n")
    print(rejtelyes_szoveg + "\n")
    print("Dekódolt szöveg:")
    print("-" * 15 + "\n")
    print(decode_message(rejtelyes_szoveg) + "\n")

if __name__ == '__main__':
    main()
			]]></programlisting>
			Itt a feladat egy példaszöveg dekódolása volt, ami korábban Caesar-kódoláson esett át, az eltolás mértéke itt kettő volt. Cél volt a formázás megtartása is, így kizárólag a betűket érintette a kód.
		</para>
		<para>
			Ennek a feladatnak a megoldása a források közt a caesar mappában található. [TODO]
		</para>
	</section>
</chapter>